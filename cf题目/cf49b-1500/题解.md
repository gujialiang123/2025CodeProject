原题：CF49b

难度：1500

算法：数学

## 思路
首先说结论,对于两个数x,y相加,最终数字的长度最多为原来的两个数中位数较多的那个数的位数加一,这个是显然的就不细说了。

而我们在考虑的时候,其实只需要考虑一个进制,即x,y各个位置上最大的那个数加一的这个进制。什么意思呢，打个比方

设x,y分别为 76617 和32219那我们就考虑 10进制，即y中最大的那个数加一为什么这样是对的呢?首先我们能够对答案作出贡献一定是因为进位,而我们得到的是在不同进制意义下相同的一个加法,所以我们考虑如何才会更容易进位,显然是基数越小越好,所以我们直接取到最小,即如果基数再小就会使式子没有意义的时候,如果连他都不能够进位,那么显然是不能对答案造成贡献的,反之答案则为x,y中较大的那个数的位数加一。

那么怎么检杳是否有解？很简单、就是 k 进制高精度加法即可、最后判断是否进位


## 实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define R register int
const int MAXN = 1e3 + 10;
int a[MAXN], b[MAXN], c[MAXN];
int main() {
    int x, y; scanf("%d%d", &x, &y);
    int cnt = 0, tot = 0, p = -1;
    while (x) {
        a[++ cnt] = x % 10;
        x /= 10; p = max(p, a[cnt]);
    }
    while(y) {
        b[++ tot] = y % 10;
        y /= 10; p = max(p, b[tot]);
    }
    int ans = max(tot, cnt);
    for(R i = 1; i <= ans; i ++) {
        c[i] += a[i] + b[i];
        if(c[i] > p) c[i + 1] ++;
    }
    if(c[ans + 1]) ans ++;
    printf("%d\n", ans);
    return 0;
}
```