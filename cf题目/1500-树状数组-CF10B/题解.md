原题：CF10B
难度：提高，1500

算法：模拟，树状数组

## 分析

暴力枚举每一个位置，可用树状数组来维护每一行的区间和，要维护每一行，所以要开 $n$ 个树状数组。可直接枚举行和列算出所有合法方案，再以贪心思想，每一次坐得尽量接近中间，即寻找花费最少的方案。

用数学方法计算花费：单个位置的花费为 $\vert x-x_0 \vert+\vert y-y_0 \vert$ ，由于是一个 $k^2$ 的电影院，所以 $x_0=y_0$ ，令 $mid=x_0=y_0$ ，则每个位置的花费为 $|x-mid|+|y-mid|$ ，一波人的花费是每个位置的花费之和。设一波来了 $m$ 个人，坐位的左端点为 $l$，则右端点为 $l+m-1$ ，花费之和可表示为：

$|x-mid|+|l-mid|+|x-mid|+|(l+1)-mid|+...+|x-mid|+|(l+m-1)-mid|$

=$m \times |x-mid|+|l-mid|+|(l+1)-mid|+...+|(l+m-1)-mid|$

**分类讨论**：

- 当 $ l\ge mid$ 时

则总花费为 $m \times |x-mid|+l-mid+(l+1)-mid+..+(l+m-1)-mid$ 

=$m \times |x-mid|+(l+l+1+l+2+...+l+m-1)-m \times mid$

用函数 cost(int l ,int r) 来求  $\sum\limits_{i=l}^ri$ ，则原式变为：

$m \times |x-mid|+cost(l,l+m-1)-m \times mid$



- 当 $ l+m-1 \le mid $ 时总花费为：$m \times |x-mid|+m \times mid-cost(l,l+m-1) $

- 当 $l<mid<l+m-1$ 时

可拆成两段来看： 在 $mid$ 右边:$m \times |x-mid|+cost(mid,y+m-1)$

$mid$ 左边：$mid \times (mid-y)-mid \times (y+m-mid)-cost(y,mid-1)$

## 实现

```c++
#include<bits/stdc++.h>
#define lowbit(x) (x&(-x))
using namespace std;
int n,k;
int tree[105][105];
//树状数组 
inline int sum(int line,int x)
{
    int res=0;
    for(int i=x;i>=1;i-=lowbit(i))
        res+=tree[line][i];
    return res;
}
inline int query(int line,int l,int r)
{
    return sum(line,r)-sum(line,l-1);
}
inline void add(int line,int x)
{
    for(int i=x;i<=k;i+=lowbit(i))
        tree[line][i]++;
}
//同上，等差数列求和 
inline int cost(int l,int r)
{
    return (l+r)*(r-l+1)>>1;
}
int main()
{
    scanf("%d%d",&n,&k);
    int mid=(k>>1)+1;
    for(int i=1;i<=n;i++)
    {
        int m;
        scanf("%d",&m);
        int ansx=-1,ansy=-1;
        int minn=0x3f3f3f3f;
        for(int x=1;x<=k;x++)//枚举行 
            for(int y=1;y+m-1<=k;y++)//枚举列 
                if(query(x,y,y+m-1)==0)//如果这一片区域没有人坐 
                {
                    int tmp;
                    if(y>=mid) tmp=cost(y,y+m-1)-mid*m+abs(x-mid)*m;
                    else if(y+m-1<=mid) tmp=mid*m-cost(y,y+m-1)+abs(x-mid)*m;
                    else tmp=abs(x-mid)*m+cost(mid,y+m-1)-(y+m-mid)*mid+mid*(mid-y)-cost(y,mid-1);//同前 
                    if(tmp<minn)
                    {
                        minn=tmp;
                        ansx=x;
                        ansy=y;
                    }
                }
        if(minn!=0x3f3f3f3f)
        {
            printf("%d %d %d\n",ansx,ansy,ansy+m-1);
            for(int j=ansy;j<=ansy+m-1;j++)
                add(ansx,j); 
        }
        else puts("-1");
    }
    return 0;
}
```