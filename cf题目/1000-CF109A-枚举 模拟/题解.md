原题：CF109A

难度：普及-，1000

算法：暴力 模拟

## 【题意概括】
给定一个数的数位和 n，要求这个数只能由 
4
4 或 
7
7 组成（即：这个数的每个数位上只能是 
4
4 或 
7
7）。

如果没有方案，则输出 
−
1
−1，否则输出最小的能满足该条件的数。

## 【思路】
既然是要最小，那么先考虑数位为 
4
4 的，每有一个数位为 
4
4 的 

n 便减 
4
4 。这是第一步。

若还有剩余的 

n ，则考虑数位为 
7
7 的每有一个数位为 
7
7 的 

n 便减 
7
7 。

不够减了怎么办？那就从 
4
4 那边借一个过来。还不够减怎么办？再借撒。借到没了怎么办？这时候就没法满足条件了，便输出 
−
1
−1 。这是第二步。

但要要球满足最小，就得尽量把位数减小。若有 
7
7 个 
4
4 就可以转换为 
4
4 个 
7
7，这是第三步（这一点作者WA了一次）。

时机成熟，是时候上代码了！其它细节也见代码~

```
#include<bits/stdc++.h>//万能头文件好
using namespace std;
#define ll long long//个人习惯
int main(){
	ll n,i=0,j=0;
	//先定义好，i是4的个数，j是7的个数，一定要初始化为0
	scanf("%lld",&n);//输入
	i=n/4;n-=i*4;//前文的第一步
	if(n){
		while(i>0){
			n+=4;i--;
			if(n%7==0){j=n/7;n=0;break;}
			//前文的第二步
		}
	}
	if(n)printf("-1\n");
	//若还有剩余的，则无法满足条件，输出-1
	else{//否则
		while(i>=7){i-=7;j+=4;}//前文的第三步
		while(i--)printf("4");//输出4
		while(j--)printf("7");//输出7
		printf("\n");//换行是个好习惯
	}
	return 0;//over~
}
```