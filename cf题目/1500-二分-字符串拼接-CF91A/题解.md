原题：CF88B
难度：普及，1500

算法：二分

## 分析

对每一个字符 $c$ 开一个<code>vector</code>，将 $s$ 中 $c$ 的位置从小到大放进 <code>vector</code> 中，判断 $t$ 中有没有 $s$ 中没有出现的字符。扫描  $t$ ，设  $t_{i-1}$ 在  $s$  中的位置为  $j$，对于一个字符 $t_i$，在  $t_i$  的  <code>vector</code> 中二分查找大于  $j$  的位置，如果找不到就跳出循环，说明要再拼接一个字符串，累加答案；如果找得到就将  $j$  更新为这个位置。二分查找可以用  <code>upper_bound</code> 。
 
## 实现

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>pos[300];//位置
int main()
{
	string s1,s2;
	int i,j,ans=0;
	cin>>s1>>s2;
	for(i=0;i<s1.size();i++)
		pos[s1[i]].push_back(i);
	for(i=0;i<s2.size();i++)
		if(pos[s2[i]].empty()) break;
	if(i<s2.size()) {cout<<-1;return 0;}
	for(i='a';i<='z';i++)
		pos[i].push_back(s1.size()+1);
	for(i=0;i<s2.size();)
	{
		ans++;
		j=*upper_bound(pos[s2[i]].begin(),pos[s2[i]].end(),-1);
		while(j<s1.size())
		{
			i++;
			if(i>=s2.size()) break;
			j=*upper_bound(pos[s2[i]].begin(),pos[s2[i]].end(),j);
		}
	}
	cout<<ans;
	return 0;
}
```