原题：CF231D

难度：1600

算法：数学 暴力

## 思路

本题思路很简单。其实就是一面一面的判断是否可以看到这面的数字，看得到 ans（答案）就加一。

那接下来就要想该如何判断是否可以看到某一面。见下：

要是 
x 轴坐标小于 
0，则看到 YOZ 面上的数字。
要是 
x 轴坐标大于 
x 轴的边长，则看到 YOZ 的对面上的数字。
其余的以此类推，那这题就解出来了！

总结
搞清楚输入顺序。
搞清楚坐标轴。

## 实现
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int cnt[10],ans;//ans为答案（你看到的数字之和），cnt为每一面上的数。 
int x,y,z;//你所处的坐标。
int s1,s2,s3;//长，宽，高。 
int main(){
	scanf("%d %d %d %d %d %d",&x,&y,&z,&s1,&s2,&s3);
	for(int i=1; i<=6; i++) scanf("%d",&cnt[i]); 
	if(y<0) ans+=cnt[1];//看到了ZOX。
	if(y>s2) ans+=cnt[2];//看到了ZOX的对面。
	if(z<0) ans+=cnt[3];//看到了XOY。
	if(z>s3) ans+=cnt[4];//看到了XOY的对面。 
	if(x<0) ans+=cnt[5];//看到了YOZ。 
	if(x>s1) ans+=cnt[6];//看到了YOZ的对面。 
	printf("%d",ans);
	return 0;
}

```