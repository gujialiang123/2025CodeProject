原题：CF33a

难度：1200

算法：模拟、贪心

## 分析

首先，做提前要先审题：
每吃掉一个食物就要消耗某一排牙齿的每一颗牙齿各1点活力；

且鲨鱼必须保证每个牙齿的剩余活力不能到负数。

所以，我们要找到每一排牙齿中活力值最小的牙齿，来作为这一排的活力值！
```cpp
int p[1005];//储存每一排的活力值
for (int i=1;i<=m;i++) p[i]=999999999;//尽量大
for (int i=1;i<=n;i++){
	cin>>x>>c;
    p[x]=min(c,p[x]);//取最小的活力值作为这一排的活力值
}
```

最后将每一排的活力值相加就可以了……
吗……
当然不行！因为食物是有限的
所以需要将可以吃的食物数和共有的食物数取最小值。
代码如下：
## 实现

```cpp
#include<bits/stdc++.h>//万能头棒棒哒
using namespace std;
int n,m,k,x,c,p[1005],ans;
int main(){
    cin>>n>>m>>k;
    for (int i=1;i<=m;i++) p[i]=999999999;//初始化，尽量大
    for (int i=1;i<=n;i++){
    	cin>>x>>c;
    	p[x]=min(c,p[x]);//计算每排活力值
	}
	for (int i=1;i<=m;i++) ans+=p[i];//能力食物数
	cout<<min(k,ans)<<endl;//最终比大小
	return 0;
}
```