原题:CF26a

难度: 900

算法:数论





我们要找恰好有两个质因数的数，因此我们要先把一个数所有的因数找出来， 然后再判断这些书里面有几个是质数。 但如果这样做应该是会超时的（我没仔细算过，但是我不是这样做的），我们可以换一种方法，用线性筛素数来找素数。我们可以开一个数组b，b[i]代表i有几个质因数。当我们发现一个数是素数时，我们就把n以内是这个数倍数的k找出来，然后b[k]++。到最后，我们再枚举1到n，b[i]如果为2，那么就把总数+1，输出总数，就是最后的答案。

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,b[3001]={0},s=0;//b的用处如上，s为1到n里面的“几乎质数”
int main()
{
	b[1]=1;//1不是质数，特判一下，
	cin>>n;
	for(int i=2;i<=n;i++)//筛素数
    //注意筛数范围，由于要找出一个数的所有质因数，所以必须枚举到n
    //而不是sqrt（n）
	if(b[i]==0)//我们用0表示这个数为质数，这里代表发现一个质数
	{
		for(int j=2;j*i<=n;j++)//把这个数的倍数都枚举一遍
		b[i*j]++;//i的倍数都加一个质因数
        //注意这里，我们在加质因数的时候，也正好把不是质数的数排除了
        //因为b[i*j]都+了1，因此他们都不是0了，所以不是质数了
	}
	for(int i=1;i<=n;i++)
	if(b[i]==2) s++;//枚举一遍，看那些数正好有两个质因数
	cout<<s;//输出总数
	return 0;
}

```
​